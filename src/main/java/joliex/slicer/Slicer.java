/*
 * Copyright (C) 2021 Valentino Picotti
 * Copyright (C) 2021 Fabrizio Montesi <famontesi@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */

package joliex.slicer;

import static java.nio.file.StandardOpenOption.CREATE;
import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
import static java.nio.file.StandardOpenOption.WRITE;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.*;
import java.util.stream.Collectors;

import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

import jolie.lang.parse.ast.EmbedServiceNode;
import jolie.lang.parse.ast.OLSyntaxNode;
import jolie.lang.parse.ast.Program;
import jolie.lang.parse.ast.ServiceNode;
import org.json.simple.parser.ParseException;

/**
 * Slicer
 */
public class Slicer {
	final Program program;
	final Path outputDirectory;
	final Set<String> services;
	final DependenciesResolver dependenciesResolver;
	Map< String, Program > slices = null;

	private Slicer( Program p, Path outputDirectory, Set<String> services )
		throws FileNotFoundException, InvalidConfigurationFileException {
		this.program = p;
		this.outputDirectory = outputDirectory;
		this.services = services;
		p.children()
			.stream()
			.filter( ServiceNode.class::isInstance )
			.map( ServiceNode.class::cast )
			.forEach( Slicer::removeAutogeneratedInputPorts );
		this.dependenciesResolver = new DependenciesResolver( p );
	}

	public static Slicer create( Program p, Path outputDirectory, Set<String> services )
		throws FileNotFoundException, InvalidConfigurationFileException {
		Slicer slicer = new Slicer( p, outputDirectory, services );
		slicer.sliceProgram();
		return slicer;
	}

	public void validateConfigurationFile( Map< String, ServiceNode > declaredServices )
		throws InvalidConfigurationFileException {
		final StringBuilder msg = new StringBuilder();
		final Path programPath = Paths.get( program.context().sourceName() ).getFileName();

		/* undeclaredServices.removeAll( declaredServices.entrySet() );
		if( !undeclaredServices.isEmpty() ) {
			for( String service : undeclaredServices ) {
				msg.append( "Service " )
					.append( service )
					.append( " in " )
					.append( configPath.getFileName() )
					.append( " is not declared in program " )
					.append( programPath )
					.append( System.lineSeparator() );
			}
		} */

		ArrayList< String > servicesWithoutParameter = declaredServices.entrySet().stream()
			.filter( e -> services.contains( e.getKey() ) && e.getValue().parameterConfiguration().isPresent() )
			.map( e -> e.getValue().name() )
			.collect( Collectors.toCollection( ArrayList::new ) );
		if( !servicesWithoutParameter.isEmpty() ) {
			for( String service : servicesWithoutParameter ) {
				msg.append( "Service " + service + " in " + programPath ).append( " does not declare a parameter" )
					.append( System.lineSeparator() );
			}
		}
		if( !msg.toString().isEmpty() ) {
			throw new InvalidConfigurationFileException( msg.toString() );
		}
	}

	private void sliceProgram() {
		/* Slices only the services mentioned in the config */
		slices = new HashMap<>();
		program.children()
			.stream()
			.filter( ServiceNode.class::isInstance )
			.map( ServiceNode.class::cast )
			// Slice only services that are present in the configuration
			.filter( s -> services.contains( s.name() ) )
			.forEach( s -> {
				// Sort dependencies by their line to preserve the ordering given by the programmer
				List< OLSyntaxNode > newProgram =
					dependenciesResolver.getServiceDependencies( s )
						.stream()
						.sorted( Comparator.<OLSyntaxNode, Integer>comparing( dep -> dep.context().startLine() ) )
						.collect( Collectors.toList() );
				newProgram.add( s );
				slices.put( s.name(), new Program( program.context(), newProgram ) );
			} );
	}

	private static void removeAutogeneratedInputPorts( ServiceNode service ) {
		ArrayList< OLSyntaxNode > toBeRemoved = service.program()
			.children()
			.stream()
			.filter( EmbedServiceNode.class::isInstance )
			.map( EmbedServiceNode.class::cast )
			.filter( EmbedServiceNode::isNewPort )
			.map( EmbedServiceNode::bindingPort )
			.collect( ArrayList::new, ArrayList::add, ArrayList::addAll );
		service.program().children().removeAll( toBeRemoved );
	}

	public void generateServiceDirectories()
		throws IOException {
		Files.createDirectories( outputDirectory );
		for( Map.Entry< String, Program > service : slices.entrySet() ) {
			JoliePrettyPrinter pp = new JoliePrettyPrinter();
			// Create Service Directory
			Path serviceDir = outputDirectory.resolve( service.getKey().toLowerCase() );
			Files.createDirectories( serviceDir );
			// Output Jolie
			Path jolieFilePath = serviceDir.resolve( service.getKey() + ".ol" );
			try( OutputStream os =
				Files.newOutputStream( jolieFilePath, CREATE, TRUNCATE_EXISTING, WRITE ) ) {
				pp.visit( service.getValue() );
				os.write( pp.toString().getBytes() );
				os.flush();
			}
		}
	}

	public Map< String, Program > getSlices() {
		return slices;
	}
}
